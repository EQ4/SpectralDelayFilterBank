/*
==============================================================================

This file was auto-generated by the Jucer!

It contains the basic startup code for a Juce application.

==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "FilterCoeffs.h"

//==============================================================================
SpectralDelayPluginAudioProcessor::SpectralDelayPluginAudioProcessor()
{
	//set the FFT size and number of filters
	N = 4096;
	numFilters = 5;
	filterVector.resize(numFilters);
	delayLineVector.resize(numFilters);
	//create filter objects and store them in the filter vector and create delay lines and store them in the delaylineVector
	for(int i = 0; i < numFilters; ++i)
	{
		filterVector[i] = new FFTfilter(filters_real[i], filters_imag[i], filter_orders[i], N);
		delayLineVector[i] = new CircularBuffer<double>();
	}
}

SpectralDelayPluginAudioProcessor::~SpectralDelayPluginAudioProcessor()
{
}

//==============================================================================
const String SpectralDelayPluginAudioProcessor::getName() const
{
	return JucePlugin_Name;
}

int SpectralDelayPluginAudioProcessor::getNumParameters()
{
	return 0;
}

float SpectralDelayPluginAudioProcessor::getParameter (int index)
{
	return 0.0f;
}

void SpectralDelayPluginAudioProcessor::setParameter (int index, float newValue)
{
}

const String SpectralDelayPluginAudioProcessor::getParameterName (int index)
{
	return String::empty;
}

const String SpectralDelayPluginAudioProcessor::getParameterText (int index)
{
	return String::empty;
}

const String SpectralDelayPluginAudioProcessor::getInputChannelName (int channelIndex) const
{
	return String (channelIndex + 1);
}

const String SpectralDelayPluginAudioProcessor::getOutputChannelName (int channelIndex) const
{
	return String (channelIndex + 1);
}

bool SpectralDelayPluginAudioProcessor::isInputChannelStereoPair (int index) const
{
	return true;
}

bool SpectralDelayPluginAudioProcessor::isOutputChannelStereoPair (int index) const
{
	return true;
}

bool SpectralDelayPluginAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
	return true;
#else
	return false;
#endif
}

bool SpectralDelayPluginAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
	return true;
#else
	return false;
#endif
}

int SpectralDelayPluginAudioProcessor::getNumPrograms()
{
	return 0;
}

int SpectralDelayPluginAudioProcessor::getCurrentProgram()
{
	return 0;
}

void SpectralDelayPluginAudioProcessor::setCurrentProgram (int index)
{
}

const String SpectralDelayPluginAudioProcessor::getProgramName (int index)
{
	return String::empty;
}

void SpectralDelayPluginAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void SpectralDelayPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
	// Use this method as the place to do any pre-playback
	// initialisation that you need..
	maxDelay = sampleRate*2;

	//resize and clear delay lines
	for(int i = 0; i < numFilters; ++i)
	{
		//ScopedPointer<CircularBuffer<double>> currentDelayLine = delayLineVector[i];
		CircularBuffer<double>& currentDelayLine = *(delayLineVector[i]);
		currentDelayLine.changeSize(maxDelay + phase_offsets[i]);
		for(int j = 0; j < maxDelay + phase_offsets[i]; ++j)
		{
			currentDelayLine[j] = 0.0;
		}
	}
}

void SpectralDelayPluginAudioProcessor::releaseResources()
{
	// When playback stops, you can use this as an opportunity to free up any
	// spare memory, etc.
}

//this plugin can only handle one channel of input and has only one channel of output
void SpectralDelayPluginAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
	// This is the place where you'd normally do the guts of your plugin's
	// audio processing...
	int numSamples = buffer.getNumSamples();
	ScopedPointer<double> doubleInput = new double[numSamples];
	ScopedPointer<double> doubleOutput = new double[numSamples];
	ScopedPointer<float> functionOutput = new float[numSamples];
	// ..do something to the data...
	float* channelData = buffer.getSampleData (0);
	//convert input data to doubles for now, ask on forums if it's possible use use doubles instead w/ AudioSampleBuffer otherwise rewrite filter's to use floats instead (maybe make a template for different numeric types)
	for(int i = 0; i < numSamples; ++i)
	{
		doubleInput[i] = channelData[i];
		functionOutput[i] = 0.0;
	}

	for(int i = 0; i < numFilters; ++i)
	{
		FFTfilter& currentFilter = *(filterVector[i]);
		CircularBuffer<double>& currentDelayLine = *(delayLineVector[i]);
		currentFilter.filter(doubleInput, doubleOutput, numSamples);
		//copy filter output to the correct delay line and copy to the function's output at the same time
		for(int j = 0; j < numSamples; ++j)
		{
			currentDelayLine.addData(doubleOutput[j]);
			functionOutput[j] += float(currentDelayLine[delayAmounts[i]]);
		}
	}
	//clear the buffer and copy the output data to it
	buffer.clear();
	buffer.copyFrom(0, 0, functionOutput, numSamples);
}

//==============================================================================
bool SpectralDelayPluginAudioProcessor::hasEditor() const
{
	return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* SpectralDelayPluginAudioProcessor::createEditor()
{
	return new SpectralDelayPluginAudioProcessorEditor (this);
}

//==============================================================================
void SpectralDelayPluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
	// You should use this method to store your parameters in the memory block.
	// You could do that either as raw data, or use the XML or ValueTree classes
	// as intermediaries to make it easy to save and load complex data.
}

void SpectralDelayPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
	// You should use this method to restore your parameters from this memory block,
	// whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
	return new SpectralDelayPluginAudioProcessor();
}
